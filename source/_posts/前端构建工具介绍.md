---
title: 前端构建工具介绍
tags: framework
categories: 前端构建
date: 2017-08-07 19:50:25
---

### Grunt and Gulp(构建工具)
-----
#### 两者优缺点对比

1. Grunt 有一个完善的社区，插件丰富. 它简单易学。（大约4000+，将近Gulp两倍);
2. Grunt 是基于文件流，Gulp是基于管道流。
3. Grunt 的缺点
    * 但插件很难遵守单一责任原则。比如说要对处理后的文件进行更名操作，你可能使用的是 uglify 插件，也有可能使用的是 concat 插件（取决于工作流的最后一个环节是谁）。对很多人来说 Grunt 插件多少存在“职责不明”和“越俎代庖”的情况。在个人看来，这也是 Grunt 一个设计思想：把对文件的操作抽象为一个独立的组（Files），任何插件都以相同的规则来使用它。遗憾在于，使用它的过程发生在每个插件的独立配置对象里，所以总给人一种“把不该这个插件做的事情丢给它来做”的别扭感觉。
    * 用插件做一些本来不需要插件来做的事情。因为 Grunt 提供了统一的 CLI 入口，子任务由插件定义，由 CLI 命令来调用执行，因此哪怕是很简单的外部命令（比如说运行 karma start）都得有一个插件来负责封装它，然后再变成 Grunt CLI 命令的参数来运行，多此一举。
    * 试图用配置文件完成所有事，结果就是混乱不堪。规模较大，构建／分发／部署流程较为复杂的项目，其 Gruntfile有多庞杂相信有经历的人都有所体会。而 gulp.js 奉行的是“写程序而不是写配置”。 
    * 落后的流程控制产生了让人头痛的临时文件／文件夹所导致的性能滞后。

Gruntfile.js范例
```
module.exports = function(grunt) {
    grunt.initConfig({
        concat: {
            'dist/all.js': ['src/*.js']
        },
        uglify: {
            'dist/all.min.js': ['dist/all.js']
        },
        jshint: {
            files: ['gruntfile.js', 'src/*.js']
        },
        watch: {
            files: ['gruntfile.js', 'src/*.js'],
            tasks: ['jshint', 'concat', 'uglify']
        }
    });
    // Load Our Plugins
    grunt.loadNpmTasks('grunt-contrib-jshint');
    grunt.loadNpmTasks('grunt-contrib-concat');
    grunt.loadNpmTasks('grunt-contrib-uglify');
    grunt.loadNpmTasks('grunt-contrib-watch');
    // Register Default Task
    grunt.registerTask('default', ['jshint', 'concat', 'uglify']);
};
```
Gulpfile.js范例
```
const gulp = require('gulp');
const jshint = require('gulp-jshint');
const concat = require('gulp-concat');
const uglify = require('gulp-uglify');
const rename = require('gulp-rename');
  
// 语法检查
gulp.task('jshint', function () {
    return gulp.src('src/*.js')
        .pipe(jshint())
        .pipe(jshint.reporter('default'));
});
  
// 合并文件之后压缩代码
gulp.task('minify', function (){
     return gulp.src('src/*.js')
        .pipe(concat('all.js'))
        .pipe(gulp.dest('dist'))
        .pipe(uglify())
        .pipe(rename('all.min.js'))
        .pipe(gulp.dest('dist'));
});
  
// 监视文件的变化
gulp.task('watch', function () {
    gulp.watch('src/*.js', ['jshint', 'minify']);
});
  
// 注册缺省任务
gulp.task('default', ['jshint', 'minify', 'watch']);
```
附录
* Gulp插件库: http://gulpjs.com/plugins
* Gulp API: https://github.com/gulpjs/gulp/blob/master/docs/API.md
* Grunt API: https://gruntjs.com/api/grunt

### Browserify and Webpack(模块化工具)
1. seajs / requirejs : 是一种在线"编译" 模块的方案，相当于在页面上加载一个 CMD/AMD 解释器。这样浏览器就认识了 define、exports、module , 也就实现了模块化。
2. browserify / webpack : 是一个预编译模块的方案，相比于上面 ，这个方案更加智能。以webpack为例。首先它是预编译的，不需要在浏览器中加载解释器。它也是基于文件流的，相较于WebPack，Browserify能够对处理过程做更精细的控制，而WebPack相对更加‘黑盒’。还有就是WebPack的生态要比Browserify好得多。

### Npm, yarn, bower
1. npm安装依赖包的时候，会将包的不同版本放在合适的地方，从而，可以在想要的地方加载想要的版本。但是，这样对于前端来说，就是噩梦了(比如有两个版本的jQuery，或者两个版本的Bootstrap)。
2. npm是为JavaScript服务的包管理器，目前的仓库中大多数都是Node.js包，使用Browserify进行适配之后，某些模块可以在客户端运行，但还有很多仍然不行。
3. npm会创建一个树形的依赖关系，而bower创建的是扁平化的层级依赖关系。
4. 树形的依赖关系的意思就是每一个包都可以有他自己的依赖包。在服务器上，这样做很好，并不用太关心空间不够用什么的。但是，在前端，这样就显得很不友好了，想象一下一个网站同时加载了三个不同版本的jQuery。
5. bower安装的目录结构是扁平的。相互依赖的包会被放到同一级目录下。由于目录扁平化，所以，发生版本冲突的时候，需要人工解决。这样，任何人得到这个项目，安装的包的版本都是相同的了。

### Yeoman
1. Yeoman 是一个通用的脚手架系统允许创建任何的 app 。它可以迅速的搭建一个新项目，并且能够简化了现有项目的维护。