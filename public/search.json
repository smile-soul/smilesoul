[{"title":"Web最佳实践阅读总结(2)","url":"/2017/10/09/Web最佳实践阅读总结-2/","content":"##### 代码符合标准\n* 标准的页面会保证正确的渲染\n* 页面容易被搜索引擎搜索，提高搜索排名(SEO)\n* 提高网站的易用性\n* 网页更好维护和扩展（Validator，HTML Validator 属于Firefox插件)\n\n##### 停止使用不标准的标签和属性，简化HTML代码\n* 标签没有实际意义，仅设置样式（不推荐使用）\n* 不推荐使用blink，marquee\n* 让HTML拥有更好的语义\n* 移除不常用的HTML标签\n\n##### 样式和结构分离\n* HTML页面链接一个CSS（最优），提高加载速度\n* HTML内嵌CSS（单一页面最佳，减少加载CSS样式文件的请求数目，加快加载速度\n* 内联CSS样式，可以使用JS动态来统一修改，很少使用，JQ中使用其实现动画效果\n* 在CSS样式文件中引用CSS文件，避免使用\n\n##### 添加JS禁用提示信息\n* 使用noscrpt，HTML4只在body中起作用，HTML5中可以出现在head中，支持HTML，不支持XHTML\n* 最好使用noscript，采用渐进增强的模式，平稳降级\n\n##### 添加必要的meta的标签\n* meta的属性：name，http-equiv，content，charset\n* name和content属性组合，构成名称/值对\n* name中keywords，description最常用\n* http-equiv和content属性结合，构成http命令\n* 其中content-type，default-style，refresh已经确定，content-language，set-cookie 未正式确定\n* charset设置编码\n\n##### 常用的meta方法\n* 设置IE浏览器的兼容性\n* 设置页面在移动设备中的显示\n* 设置IE浏览器的固定网站功能\n\n##### HTML语义化\n* 语义化使搜索引擎和第三方抓取工具更容易读懂代码\n* 去掉CSS也可以保持良好的外观\n* div，span尽量少使用\n* 把无关的元素重HTML中删除\n* 添加一些隐藏文字\n* 要求：\n\t* 熟悉所有规范中的HTML标签，理解各标签的语义\n\t* 熟悉各标签上规范的属性，给HTML标签设置必要的属性\n\t* 样式和结构的分离\n* 构建页面标题的最佳实践：\n\t* 使用hx标签\n\t* 页面只是使用一个h1\n\t* hx使用过程中不要跳级\n\t* 不要使用hx设置样式\n* 设计表单：\n\t* 使用label标签，并设置label标签的for属性\n\t* 给输入控件设置合适的水印提示\n\t* 输入控件设置tab顺序\n\t* 使用HTML5中引入的表单控件\n\t\n##### HTML5新特性使用\n* async和defer属性\n\t* 不使用在内联里面\n\t* defer：以并行的方式下载脚本，而不是阻塞的方式下载，在脚本加载完成后，浏览器会在DOM触发之前按照引用顺序运行JS\n\t* async：以异步的方式下载脚本，在下载结束后立即执行代码，而不会等待页面解析结束\n\t* 在设置async时候，推荐同时设置defer属性，提高脚本加载执行的性能\n* 标签上的自定义属性data-\\*\n* script可以编写HTML模板和XML数据\n    \n##### 选择器注意\n* 尽量不使用ID选择器\n* 减少子选择器的层级（less和Sass的滥用）\n* 使用组合CSS类选择器\n\t\n##### 兼容IE浏览器\n* 兼容旧浏览器的代码，被称为hack代码\n* 熟悉IE浏览器中常见的兼容样式\n* 分离样式兼容代码\n\n\t```\n            .color{ _color:green;}  ( IE6 (含 IE6 ) 以下)\n                    \n            .color{ *color:gray; }  ( IE7 ( 含 IE7 )以下)\n                    \n            .color { color:green \\0; } ( IE8 + )\n                \n            .color { color:green \\ ; }   ( IE8 . IE9 )\n                    \n            :root .color { color:green \\0; } ( IE9 + )\n                    \n            .color { color:green \\9\\0; }   ( IE9+ )\n                    \n            .color { color:green \\9; }   ( IE10 ( 含 IE10 ) 以下 )\n                    \n            *::-ms-backdrop, .color{ color:red; }   ( IE11 )\n                    \n            * html .color { color: red; } (IE6 ONLY )\n                    \n            *+html .color { color: red; } ( IE7 ONLY )\n                    \n            @media screen\\9 { \n                    .color { color: black; } \n                    }  ( IE6 . IE7 )      \n            @media \\0screen {\n                     .color { color: black; } \n                    }  ( IE8 ONLY )      \n            @media \\0screen, screen\\9 {\n                     .color { color: black; } \n                    } ( IE6 . IE7 . IE8 ) \n            @media screen\\0 {\n                     .color { color: black; } \n                    }  ( IE8 . IE9 . IE10 )\n                    @media screen and (min-width: 0\\0) {\n                     .color { color: black; }\n                    }  ( IE9 . IE10 )\n                    \n            \n            @media screen and (-ms-high-contrast: active), (-ms-high-contrast: none) { \n            .color { color: black; }\n            }   ( IE10 ONLY )\n            \n            @media all and (-ms-high-contrast:none){\n            .color { color:greeny \\0; }\n            } ( IE10 + )\n            \n            @media all and (-ms-high-contrast:none){ \n            *::-ms-backdrop, .color { color:green \\0; }\n             } ( IE11 + )\n```\n\n##### em，px，%\n* px：绝对尺寸，em：应用元素上字体大小的两倍，%：相对于父元素的百分比\n* 尽量设置相对尺寸\n* 只有在可预知元素尺寸的情况下才使用绝对尺寸\n* 使用em设置字体的大小\n\n----\n* [常用的meta方法](http://www.haorooms.com/post/html_meta_ds) \n* [CSS: em, rem区别](https://webdesign.tutsplus.com/zh-hans/tutorials/comprehensive-guide-when-to-use-em-vs-rem--cms-23984)\n* [script的defer和async](http://ued.ctrip.com/blog/script-defer-and-async.html)","tags":["JavaScript"],"categories":["编程语言"]},{"title":"Web最佳实践阅读总结(1)","url":"/2017/10/05/Web最佳实践阅读总结-1/","content":"![](https://badge.juejin.im/entry/59d9c9dcf265da06456da777/likes.svg?style=flat-square)\n### 介绍\n----\n最近开始刷一些书和题,此系列是介绍在读`Web最佳实践`的一些收获和体会。\n![](http://ou42j47mq.bkt.clouddn.com/2017-10-05-webbest.jpg)\n---\n##### web前端发展现状\n * 存在问题：\n    * 代码组织混乱\n    * 代码格式的问题突出\n    * 页面布局随意\n    * 网站整体性能差，没有意识到应用诸如缓存，动态加载，脚本压缩，图片压缩等提高性能技术\n * 推荐做法：\n    * 压缩样式表和脚本文件\n    * 减少HTTP请求次数\n    * 简洁和符合W3C标准的HTML和CSS代码能减少浏览器解析的时间，加快渲染过程\n    * 页面请求数量越少，相对页面的加载速度更快\n    * 在JS代码中选择性能更好的实现方案，如延迟加载，动态加载等技术;\n * 延迟加载\n    ```\n    <script type=”text/javascript” src=”\" id=”my”></script> \n    <script type=”text/javascript”> \n    setTimeout(“document.getElementById(‘my').src='include/php100.php'; “,3000);//延时3秒 \n    </script> \n\n    ```\n * 最后加载\n    * 引入外部js脚本文件时，如果放入html的head中,则页面加载前该js脚本就会被加载入页面，而放入body中，则会按照页面从上倒下的加载顺序来运行javascript的代码，所以可以把js外部引入的文件放到页面底部，来让js最后引入，从而加快页面加载速度\n * 动态加载\n    ```\n    \n        <scrīpt src='' id=\"s1\"></scrīpt> \n        <scrīpt language=\"javascrīpt\"> \n        s1.src=\"test.js\" \n        </scrīpt> \n    ```\n##### 前端代码重构\n * 删除无用代码，精简代码（不起作用的CSS样式和废弃的JavaScript函数）\n * 前端代码规范化，把CSS代码放到独立的文件中，在JS定义局部变量，把部分全局变量改变成局部变量\n * 前端代码模块化，引入面向对象的思想来重构JavaScript代码，进一步明确公有接口和私有接口\n * 提高页面性能：\n    * 将部分不影响首页展示的JS文件延迟到页面的加载后加载\n    * 删除页面中初始隐藏的区域，改为通过JS按需动态生成\n    * 页面中的部分图片延迟加载\n    * 调整CSS和JS文件引用顺序，即CSS在前，JS在后\n    * 给静态文件设置缓存，使用CSS Sprite，合并背景图\n    * 合并和压缩发布后的CSS和JS代码模块\n * 前端重构最佳实践\n    * 重构前一定要预测风险，最好先完善自动化测试代码\n    * 重构的目的和范围要明确，提高代码的可维护性，可读性和性能\n    * 最好先易后难，循序渐进。先修改诸如命名，格式等不涉及具体逻辑的内容\n    * 重构过程中要持续测试，在多个浏览器测试，确保重构的部分功能正确。切记大量重构后再进行测试，因为大量重构后基本很难记得重构的逻辑，也可能遗漏部分测试用例\n    * 性能提升，先进行检测网站的整体性能并量化，找出性能瓶颈。重构过程中要持续监控性能，并进行对比\n##### 前端框架的使用\n * 项目需求\n    * 调查项目是否需要AJAX操作\n    * 是否需要模块化\n    * 数据传输格式JSON或者XML\n    * 需要支持的浏览器\n    * 移动还是普通网站\n    * 需要的UI模块（模态窗口，滑块控件，进度条，提示框，分割框，幻灯显示，自动填充）\n * 项目的特点\n * 框架的特点\n##### 代码质量\n * 编写高质量，标准的HTML（标准校验工具，ESLint, Flow, JSDoc, ts）\n * 明确浏览器支持范围\n    * Chrome和Safari  IE Tester（IE兼容测试工具\n * 避免浏览器兼容性的问题\n    * 先考虑更改方案，使用没有兼容问题的代码\n    * 考虑如何兼容的问题\n    * 兼容IE，使用IE特有的条件表达式(hack)\n    * 让兼容的代码独立，提高代码的可维护性\n * HTML5新特性\n    * 新标签的兼容，CSS3的兼容，新增的API（使用html5shiv框架）\n    * CSS3本身不支持，会直接忽略\n    * 新增加的接口的使用，必须添加条件判断（Modernizr）\n    * 多看Can I use\n##### web性能分析\n * YSlow，pagespeed\n    * 基于不同的规则评定网站整体性能评分\n    * 给出提高网页性能的建议\n    * 统计页面加载的组件\n    * 页面的统计信息视图\n    * 相关性能分析工具集：Smush.it\n * Chrome开发工具\n    * Network中可以查看各资源请求和下载所用的时间\n    * Timeline可以查看网页渲染和交互过程中个步骤所花费的时间，从资源到JS的解析执行，样式的应用和绘制\n    * Profiles中可以查看网页的CPU及内存占有情况报告\n    * Audits中提供了各种资源和配置优化的建议和未使用CSS规则的列表\n * 加快代码和资源文件传输的方式\n    * CDN分发\n    * 缓存(meta)\n    * 压缩代码和资源文件（最优）\n    * Gzip算法（压缩，header可以检查是否开启）\n    * JS压缩（UglifyJS压缩和优化，YUI Compressor 仅压缩，Closure Compiler压缩和优化）\n    * CSS(CSS Compressor,YUI Compressor)\n    * HTML(HtmlCompressor使用时仔细调查和测试，避免压缩工具和破坏)\n    * 图片资源压缩（TinyPNG，JPEGmini，ImageOptim)\n\n---\n* Airbnb规范: https://github.com/airbnb/javascript\n* Eslint规范: https://eslint.org/docs/rules/\n* Beachmark.js性能测试: https://benchmarkjs.com/docs#toc\n\n","tags":["JavaScript"],"categories":["编程语言"]},{"title":"Lodash相关技巧","url":"/2017/09/29/变量和方法/","content":"### 变量和方法\n---\n#### 类型\n * js的变量中只用primitive类型和object类型\n * 平时使用的字符串应该是primitive类型，应该是not an object and has no methods\n\n\t```\n\t\tconst str = 'hello';\n\t\tconsole.log(str.charAt(0));\n\t\t// output: h\n\t\tObject.prototype.toString.call(str)\n\t\t// output: [object String]\t\n\t```\n * 出现这样的情况，因为str.charAt时候，String(primitive)转换成了String(object)类型在[ECMAScript Language Specification&8.7.1](http://www.ecma-international.org/ecma-262/5.1/#sec-8.7) 明确指出变量类型的转换\n * 所以primitive类型的value是immutable的，而variable是mutable的，对与primitive类型的变量，为其赋值，本质上就是让变量指向新的内存。\n\n---\n\n#### lodash相关技巧和实例\n  * N次循环技巧\n \t\n\t```\n    for(let i = 0; i < 5; i++) {\n        // ...\n    }\n    Array.apply(null, Array(5)).forEach(() => {\n        // ...\n        });\n    _.times(5, () => {\n        // ...\n        };\n    ```\n\n  * 深层次查找属性\n  \t\n    ```\n        const ownerArr = [{\n    \t\"owner\": \"Colin\",\n      \t\"pets\": [{\"name\":\"dog1\"}, {\"name\": \"dog2\"}]\n        }, {\n            \"owner\": \"John\",\n            \"pets\": [{\"name\":\"dog3\"}, {\"name\": \"dog4\"}]\n        }];\n\n        ownerArr.map(owner => {\n            return owner.pets[0].name;\n            });\n\n        _.map(ownerArr, 'pets[0].name');\n    ```\n  \t\n  * 数组独立\n  \t\n    ```\n        Array.apply(null, Array(6)).map( (item, index) => {\n        return \"ball_\" + index;\n        });\n\n        _.times(6, _.uniqueId.bind(null, 'ball_'));\n\n        _.times(6, _.partial(_.uniqueId, 'ball_'));\n        // output: [ball_0, ball_1, ball_2, ball_3, ball_4, ball_5]\n    ```\n  * 对象扩展(可以直接用Object.assgin(), 底层一样的实现）\n  \t\n    ```\n         Object.prototype.extend = obj => {\n    \tfor (let i in obj) {\n      \t\tif (obj.hasOwnProperty(i)) {\n        \t\tthis[i] = obj[i];\n      \t\t}\n    \t}\n    };\n        const objA = {\"name\": \"colin\", \"car\": \"suzuki\"};\n        const objB = {\"name\": \"james\", \"age\": 17};\n\n        objA.extend(objB);\n        console.log(objA); \n        // {\"name\": \"james\", \"age\": 17, \"car\": \"suzuki\"};\n\n        _.assign(objA, objB);\n        // {\"name\": \"james\", \"age\": 17, \"car\": \"suzuki\"};\n\n        // ES6\n        Objetct.assign({}, objA, objB);\n        // {\"name\": \"james\", \"age\": 17, \"car\": \"suzuki\"};\n        //_.assign 是浅拷贝，所以会覆盖name\n    ```\n  * 补充作用域：\n    \n    ```\n    const test = '1';\n    testOne() {\n        return testTwo{\n            cosole.log(test);\n        };\n        const test = '2';\n    }\n    testOne()();\n    // output: undefined \n    \n    \n    const test = '1';\n    testOne() {\n        return testTwo{\n            console.log(test);\n        };\n        test = '2';\n    }\n    // output: 1;\n    ```\n    因为重新定义了const，他在搜索作用域时候，会自上到下搜索**声明**的变量，如果没有声明，查找才会进去下一层，此处输出undefined，因为在testOne（）里面const之前就使用了test，所以就输出了undefined,而在第二个例子里面没有声明test，所以他就跳转出去，去下一层寻找test，即输出为1\n  \t\n * 作用域提升\n \n\t```\n        const a = 1;\n        b(){\n            const a = b = 2;\n        }\n        console.log(a, b);\n        // 抛出异常，因为ｂ没有定义\n        \n        b();\n        console.log(a, b);\n        //output: 1,2;\n        // const a = b = 2 等价于　在全局声明const b = 2; 内部声明const a = b;因为=运算符是重右像左运算的\n    ```\n---\n#### 附录\n * [MDN连接文档](https://developer.mozilla.org/en-US/docs/Glossary/Primitive)\n * [lodash相关技巧](http://colintoh.com/blog/lodash-10-javascript-utility-functions-stop-rewriting)\n * [10个ES6可以代替lodash的方法](https://www.sitepoint.com/lodash-features-replace-es6/)","tags":["JavaScript"],"categories":["编程语言"]},{"title":"Object","url":"/2017/09/29/object/","content":"\n### Object属性：\n---\n1. configurable: true\n\t* 能否用delete删除属性\n\t* 能否修改属性的特性\n\t* 能否把属性修改为访问器属性\n2. enumerable: true\n\t* 能否用for-in循环返回属性（是否可枚举）\n3. writable：true\n\t* 能否修改属性的值\n4. value：undefined\n\t* 包含这个属性的数据\n5. Object.defineProperty(obj, 'name', {}) (ES5)\n\n\t```\n\tObject.defineProperty(obj, 'key', {\n\t\tenumerable: false,\n\t\tconfigurable: false,\n\t\twritable: false,\n\t\tvalue: 'static'\n\t});\n\t```\n6. Object.defineProperty(obj, {})\n\t\n\t```\n\tconst obj = {};\n\tObject.defineProperties(obj, {\n\t\t\"property1\": {\n\t\t\tvalue: true,\n\t\t\twritable: true\n\t\t},\t\n\t\t\"property2\": {\n\t\t\tvalue: \"Hello\",\n\t\t\twritable: false\n\t\t\t}\n\t\t});\t\n\t\n\tcosnt obj = {};\n\tObject.defineProperty(obj, 'key', {});\n\tObject.getOwnPropertyDescriptor(obj, 'key');\t\t\t\n\t// output: Object {\n\t\tvalue: undefined, \n\t\twritable: false, \n\t\tenumerable: false, \n\t\tconfigurable: false}\n\t\t\n\t// 注意：在这样定义时候，非定义的configurable等为false\n\tobj.name = 'lty';\n\t//这样定义的时候，configurable等才为true\n\t\n\t```\n7. 一旦把configurable设为false，就不能设回成true，即一切配置都不可使用。\n\n---\n### 访问器属性\n1. configurable: true\n\t* 能否用delete删除属性\n\t* 能否修改属性的特性\n\t* 能否把属性修改为访问器属性\n2. enumerable: true\n\t* 能否用for-in循环返回属性（是否可枚举）\n3. get: undefined\n\t* 读取数据时候调用\n4. set：undefined\n\t* 写入属性时候调用\n5. 访问器属性不能直接定义，只能使用Object.defineProperty()来定义\n6. 因为 primitive 是 immutable 的,所以赋值分配新的内存,即为写入\n\n\t```\n\t\tconst book = {\n\t\t\t_year: 2004,\n\t\t\tedition: 1,\n\t\t}\n\t\tObject.defineProperty(book, 'year', {\n\t\t\tget: () => this._year,\n\t\t\tset: newline => {\n\t\t\t\tif\t(newline > 2000) {\n\t\t\t\t\tthis._year = newline;\n\t\t\t\t\tthis.edition += 1;\n\t\t\t\t};\n\t\t\t},\n\t\t})\n\t\tbook.year = 2005;\n\t\tconsole.log(edition);\n\t\t// output: 2\n\t```\n7. 浏览器中一般是使用_defineGetter_和_defineSetter_来代替\t","tags":["JavaScript"],"categories":["编程语言"]},{"title":"个人插件","url":"/2017/09/29/个人插件/","content":"\n### Alfred的相关插件\n---\n* AboutThisMac: 列出系统相关配置信息\n* colors: 前端选取颜色列表，查询颜色rgb,hsl值等\n* Hash: 文件hash加密\n* KD: 快递快速查询\n* npm: npmio快速查询\n* RMB: 人民币数汉转换\n* shanbay: 扇贝中英文翻译\n* StackOverflow: stackoverflow快速查询\n* YD: 有道词典中英文翻译\n* YDI: 有道词典加强中英文翻译\n---\n### Chrome的相关插件\n\n---\n* 1Password: 密码管理\n* Advanced REST client: 正则表达式\n* Checker Plus for Gmail: Gmail邮箱\n* Chrono Download Manager: 下载器\n* Hide Files on GitHub: 隐藏Github的所有只有扩展名文件\n* History Trends: chrome历史浏览记录\n* IcoMoon: icoMoon网站\n* Insight.io for Github: github的tree推荐\n* Isometric Contributions: github的commit大楼\n* JavaScript Errors Notifier: JavaScript的浏览器报错\n* JSON Formatter: JSON格式自动切换\n* OneTab: 所有Tab页面集合一个Tab页面\n* OctoLinker: github代码包连接跳转\n* npmhub: npmhub包自动跳转\n* Pocket: plan记录\n* Postman: api请求测试\n* Proxy SwitchyOmega: 翻墙代理必备\n* Quick Javascript Switcher: 快速关闭JavaScript脚本使用\n* Scratch JS: 浏览器内置coderunnner\n* Speedtest by Ookla: 网页测速\n* Tampermonkey: 插件大合集搜索网站,可查找需要的插件\n* The Great Suspender: 自动挂载长期未使用的页面，节省内存空间\n* Vimium: 网页版vim\n* WhatFont: 查看当前网页标签内字体\n* ZenHub for GitHub: Github中的board\n\n---\n\n### VScode 插件合集\n\n---\n* Auto Rename Tag: HTML自动修改标签\n* Auto-Open Markdwon Preview: 编写markdown必备，自动开启Preview模式\n* AutoFileName: 文件名字自动提示\n* Can I Use: CSS兼容性显示\n* Code Runner: 代码运行环境\n* Color Hightlight: 颜色自动显色\n* Docker: Docker管理\n* Document this: 自动添加注释\n* EditorConfig for VSCode: 文件格式自动整理\n* Git History: git log记录查看\n* Git lens: 代码编写提交历史查看\n* JavaScript code snippets: JavaScript的snippets\n* kubernetes Support: kubernetes的配置文件\n* Nodejs Modules Intellisense: node内置模块包提示\n* npm: npm包的提示操作，记录哪些包未使用或者未安装\n* npm Dependency: 可自动更新npm包的相关版本\n* Project Manager: 项目管理\n* Setting Sync: 插件同步管理\n* vscode-icons: vscode的Icon图标\n\n---\n* 希望各位大佬来补充，相互交流，扩充插件库\n\n\n- Github地址: https://github.com/smile-soul\n- 个人Blog: http://www.smilesoul.cn/\n\n","tags":["tools"],"categories":["开发工具"]},{"title":"前端构建工具介绍","url":"/2017/08/07/前端构建工具介绍/","content":"\n### Grunt and Gulp(构建工具)\n-----\n#### 两者优缺点对比\n\n1. Grunt 有一个完善的社区，插件丰富. 它简单易学。（大约4000+\b，\b将近Gulp两倍);\n2. Grunt 是基于文件流，Gulp是基于管道流。\n3. Grunt 的缺点\n    * 但插件很难遵守单一责任原则。比如说要对处理后的文件进行更名操作，你可能使用的是 uglify 插件，也有可能使用的是 concat 插件（取决于工作流的最后一个环节是谁）。对很多人来说 Grunt 插件多少存在“职责不明”和“越俎代庖”的情况。在个人看来，这也是 Grunt 一个设计思想：把对文件的操作抽象为一个独立的组（Files），任何插件都以相同的规则来使用它。遗憾在于，使用它的过程发生在每个插件的独立配置对象里，所以总给人一种“把不该这个插件做的事情丢给它来做”的别扭感觉。\n    * 用插件做一些本来不需要插件来做的事情。因为 Grunt 提供了统一的 CLI 入口，子任务由插件定义，由 CLI 命令来调用执行，因此哪怕是很简单的外部命令（比如说运行 karma start）都得有一个插件来负责封装它，然后再变成 Grunt CLI 命令的参数来运行，多此一举。\n    * 试图用配置文件完成所有事，结果就是混乱不堪。规模较大，构建／分发／部署流程较为复杂的项目，其 Gruntfile有多庞杂相信有经历的人都有所体会。而 gulp.js 奉行的是“写程序而不是写配置”。 \n    * 落后的流程控制产生了让人头痛的临时文件／文件夹所导致的性能滞后。\n\nGruntfile.js范例\n```\nmodule.exports = function(grunt) {\n    grunt.initConfig({\n        concat: {\n            'dist/all.js': ['src/*.js']\n        },\n        uglify: {\n            'dist/all.min.js': ['dist/all.js']\n        },\n        jshint: {\n            files: ['gruntfile.js', 'src/*.js']\n        },\n        watch: {\n            files: ['gruntfile.js', 'src/*.js'],\n            tasks: ['jshint', 'concat', 'uglify']\n        }\n    });\n    // Load Our Plugins\n    grunt.loadNpmTasks('grunt-contrib-jshint');\n    grunt.loadNpmTasks('grunt-contrib-concat');\n    grunt.loadNpmTasks('grunt-contrib-uglify');\n    grunt.loadNpmTasks('grunt-contrib-watch');\n    // Register Default Task\n    grunt.registerTask('default', ['jshint', 'concat', 'uglify']);\n};\n```\nGulpfile.js范例\n```\nconst gulp = require('gulp');\nconst jshint = require('gulp-jshint');\nconst concat = require('gulp-concat');\nconst uglify = require('gulp-uglify');\nconst rename = require('gulp-rename');\n  \n// 语法检查\ngulp.task('jshint', function () {\n    return gulp.src('src/*.js')\n        .pipe(jshint())\n        .pipe(jshint.reporter('default'));\n});\n  \n// 合并文件之后压缩代码\ngulp.task('minify', function (){\n     return gulp.src('src/*.js')\n        .pipe(concat('all.js'))\n        .pipe(gulp.dest('dist'))\n        .pipe(uglify())\n        .pipe(rename('all.min.js'))\n        .pipe(gulp.dest('dist'));\n});\n  \n// 监视文件的变化\ngulp.task('watch', function () {\n    gulp.watch('src/*.js', ['jshint', 'minify']);\n});\n  \n// 注册缺省任务\ngulp.task('default', ['jshint', 'minify', 'watch']);\n```\n附录\n* Gulp插件库: http://gulpjs.com/plugins\n* Gulp API: https://github.com/gulpjs/gulp/blob/master/docs/API.md\n* Grunt API: https://gruntjs.com/api/grunt\n\n### Browserify and Webpack(模块化工具)\n1. seajs / requirejs : 是一种在线\"编译\" 模块的方案，相当于在页面上加载一个 CMD/AMD 解释器。这样浏览器就认识了 define、exports、module , 也就实现了模块化。\n2. browserify / webpack : 是一个预编译模块的方案，相比于上面 ，这个方案更加智能。以webpack为例。首先它是预编译的，不需要在浏览器中加载解释器。它也是基于文件流的，相较于WebPack，Browserify能够对处理过程做更精细的控制，而WebPack相对更加‘黑盒’。还有就是WebPack的生态要比Browserify好得多。\n\n### Npm, yarn, bower\n1. npm安装依赖包的时候，会将包的不同版本放在合适的地方，从而，可以在想要的地方加载想要的版本。但是，这样对于前端来说，就是噩梦了(比如有两个版本的jQuery，或者两个版本的Bootstrap)。\n2. npm是为JavaScript服务的包管理器，目前的仓库中大多数都是Node.js包，使用Browserify进行适配之后，某些模块可以在客户端运行，但还有很多仍然不行。\n3. npm会创建一个树形的依赖关系，而bower创建的是扁平化的层级依赖关系。\n4. 树形的依赖关系的意思就是每一个包都可以有他自己的依赖包。在服务器上，这样做很好，并不用太关心空间不够用什么的。但是，在前端，这样就显得很不友好了，想象一下一个网站同时加载了三个不同版本的jQuery。\n5. bower安装的目录结构是扁平的。相互依赖的包会被放到同一级目录下。由于目录扁平化，所以，发生版本冲突的时候，需要人工解决。这样，任何人得到这个项目，安装的包的版本都是相同的了。\n\n### Yeoman\n1. Yeoman 是一个通用的脚手架系统允许创建任何的 app 。它可以迅速的搭建一个新项目，并且能够简化了现有项目的维护。","tags":["framework"],"categories":["前端构建"]},{"title":"原型函数Construction解析","url":"/2017/07/06/JavaScript-constructor/","content":"\n### 理解原型之间的关系\n\n```\n    testOne() {};\n    testOne.prototype\n    // Object {\n            constructor: a()\n                    arguments: null\n                    caller: null\n                    length: 0\n                    name:\"a\"\n                    prototype: Object\n                    __proto__: ()\n                    <function scope>\n                    //注意层级关系\n            __proto__: Object\n        }\n        \n        \n    testOne.length\n    // output: 0\n    \n    \n    testOne.prototype.name = '2';\n    testOne.name\n    // output: 'a';\n```\n**注意**: 这里输出为'a'，而不是２，它会去查constructor里面的name，因为prototype.constructor是会指回testOne，如果要获取＇２＇，只能testOne.prototype.name来获取.\n\t\n```\t\t\t\n    const testTwo = new testOne();\n    testTwo.prototype\n    //output: undefined\n```\n\n**注意**: 每创建一个函数才会创建它的prototype对象，使用new，不会创建prototype对象\n    \n```   \n    testTwo.constructor\n    //output: testOne(){}\n    \n    testTwo.constructor.name = 'b';\n    testTwo.name\n    // output: testTwo\n    \n    Object.getOwnPropertyDescriptor(ｔｅｓｔTwo, 'name');\n    // output: {value: \"testTwo\", writable: false, enumerable: false, configurable: true} \n```\n\n所有原声的只可以delete，之后testOne.name输出为＇＇，不能修改.\n\n```\n    testTwo.constructor.names = 'c';\n    testTwo.names\n    // output: c\n    \n    Object,getOwnPropertyDescriptor(testTwo, 'names');\n    // output: {value: \"c\", writable: true, enumerable: true, configurable: true}\n```\n\n非原生的属性，添加之后可以修改,所以在执行new操作时，将tetTwo的指针指向了\btestTwo.constructor\n\t\n```\n    testOne.prototype.newOne = '5';\n    testTwo.newOne\n    // output: '5'\n    testTwo.newOne = '6';\n    testTwo.newOne\n    // output: '6'\n    testTwo\n    // output: \n        bbb:\"444\"\n        __proto__:\tObject\n            bbb: \"2\"\n            constructor: d()\n            ＿_proto__: Object\n```\n\nnewOne　屏蔽掉了原属性，因为将怎么testOne的指针指＿proto＿\n\n```\n    Object.keys(testTwo);\n    // output: ['bbb']    \n```\n\n这也是为什么Object.keys只出现bbb，因为＿proto＿，constructor不可枚举.\n\n\n```\n    const name(){};\n    name.prototype;\n    // output: constructor: name()\n                __proto__:Object               \n    const nameTwo(){};\n    nameTwo.prototype = {};\n    nameTwo.prototype;\n    // output: __proto__:Object\n```\n这也切断了与原型之间的联系，constructor变成了＿ｐｒｏｔｏ＿的属性\n\n\n```\n    const nameThree(){};\n    Object.getOwnPropertyDescriptor(nameThree.prototype, 'constructor');\n    // output: { writable: true, enumerable: false, configurable: true }\n    nameThree.prototype = { constructor: nameThree};\n    Object.getOwnPropertyDescriptor(nameThree.prototype, 'constructor');\n    // output: {writable: true, enumerable: true, configurable: true}\n```\n\n操作prototype会使，constructor消失，如果手动改变，这会使constructor种的enumerable变成true（即可枚举）\t","tags":["JavaScript"],"categories":["编程语言"]}]